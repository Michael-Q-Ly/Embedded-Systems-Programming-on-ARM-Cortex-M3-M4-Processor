/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/**
 * Generate the below peripheral interrupts using NVIC interrupt pending
 * register and observe the execuion of ISRs when priorities are same
 * and different
 * 
 * TIM2 global interrupt
 * I2C1 event interrupt
 */
#include <stdint.h>
#include <stdio.h>
#include "main.h"

/* Macros */
#define IRQNO_TIMER2    28                                                      // TIM2 global interrupt; refer to vector table for these numbers
#define IRQNO_I2C1      31                                                      // I2C1 event interrupt

void TIM2_IRQHandler(void) ;
void I2C1_EV_IRQHandler(void) ;

/* Global pointers */
uint32_t    *pNVIC_IPRBase  = (uint32_t*) (0xE000E400) ;                        // NVIC IPR Base Address
uint32_t    *pNVIC_ISERBase = (uint32_t*) (0xE000E100) ;                        // NVIC ISER Base Address
uint32_t    *pNVIC_ISPRBase = (uint32_t*) (0XE000E200) ;                        // NVIC ISPR Base Address

int main(void) {
    initialise_monitor_handles() ;                                          	// Debugger

    // 1. Let's configure the priority for the peripherals
    configure_priority_for_irqs(IRQNO_TIMER2, 0x80) ;
#if 0
    configure_priority_for_irqs(IRQNO_I2C1, 0x80) ;
#else                                                                           // Make I2C a higher priority by changing from 0x80 to 0x70
    configure_priority_for_irqs(IRQNO_I2C1, 0x70) ;                             // Interrupt Nesting ; This interrupts in the middle
                                                                                // of another interrupt and pends the interrupt that called it
#endif
    // 2. Set the interrupt pending bit in the NVIC PR
    *pNVIC_IPRBase  |= (1 << IRQNO_TIMER2) ;
    *pNVIC_IPRBase  |= (1 << IRQNO_I2C1) ;

    // 3. Enable the IrQs in NVIC ISER
    *pNVIC_ISERBase |= (1 << IRQNO_I2C1) ;
    *pNVIC_ISERBase |= (1 << IRQNO_TIMER2) ;

    // 4. Set the interrupt pending bit in the NVIC PR
    *pNVIC_ISPRBase |= (1 << IRQNO_TIMER2) ;
    *pNVIC_ISPRBase |= (1 << IRQNO_I2C1) ;

    while (1) ;
}

/* ISRs */

void TIM2_IRQHandler(void) {
    printf("[TIM2_IRQHandler]\n") ;
    *pNVIC_IPRBase |= (1 << IRQNO_I2C1) ;
    while (1) ;
}

void I2C1_EV_IRQHandler(void) {
    printf("[I2C1_EV_IRQHandler]\n") ;
}

void configure_priority_for_irqs(uint8_t irq_no, uint8_t priority_value) {
    // 1. Find out IPRx and its address
    uint8_t     IPRx    = irq_no / 4 ;
    uint32_t    *IPR    = pNVIC_IPRBase + IPRx ;

    // 2. Find position in IPRx
    uint8_t pos = (irq_no % 4) * 8 ;

    // 3. Configure the priority
    *IPR &= ~(0xFF << pos) ;                                                    // Clear priority field
    *IPR |= (priority_value << pos) ;                                           // Program
}
