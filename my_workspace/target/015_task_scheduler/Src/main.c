/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "main.h"
#include <stdio.h>
#include <stdint.h>

/* Function Prototypes */
extern void initialise_monitor_handles(void) ;									// Debugger
void task1_handler(void) ;                                                      // This is task1
void task2_handler(void) ;                                                      // This is task2
void task3_handler(void) ;                                                      // This is task3
void task4_handler(void) ;                                                      // This is task4

void init_systick_timer(uint32_t tick_hz) ;
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack) ;
void init_tasks_stack(void) ;
void enable_processor_faults(void) ;
__attribute__((naked)) void switch_sp_to_psp(void) ;
uint32_t get_psp_value(void) ;

uint32_t psp_of_tasks[MAX_TASKS] = {T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START} ;
uint32_t task_handlers[MAX_TASKS] ;
uint8_t current_task = 0 ;                                                      // Task 1 is running

int main(void)
{
	initialise_monitor_handles() ;                                          	// Debugger

    enable_processor_faults() ;

    init_scheduler_stack(SCHED_TASK_START) ;

    task_handlers[0] = (uint32_t)(task1_handler) ;
    task_handlers[1] = (uint32_t)(task2_handler) ;
    task_handlers[2] = (uint32_t)(task3_handler) ;
    task_handlers[3] = (uint32_t)(task4_handler) ;

    init_systick_timer(TICK_HZ) ;

    switch_sp_to_psp() ;

    task1_handler() ;    

    /* Loop forever */
	for(;;);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Function Definitions */

void task1_handler(void) {

    while(1) {
        printf("This is task1\n") ;
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void task2_handler(void) {

    while(1) {
        printf("This is task2\n") ;
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void task3_handler(void) {

    while(1) {
        printf("This is task3\n") ;
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void task4_handler(void) {

    while(1) {
        printf("This is task4\n") ;
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void init_systick_timer(uint32_t tick_hz) {
    uint32_t *pSRVR         = (uint32_t*)(SYST_RVR_ADDR) ;                          // Reset Value Register
    uint32_t *pSCSR         = (uint32_t*)(SYST_CSR_ADDR) ;                          // Control and Status Register
    // To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1
    uint32_t count_value    = (SYSTICK_TIM_CLK/tick_hz) - 1 ;

    // Clear the value of SVR
    *pSRVR &= ~(0x00FFFFFF) ;                                                       // Only 24 bits available for reload

    // Load the value into SVR
    *pSRVR |= count_value ;

    // Do some settings: Enable SysTick exception request and indicate the clock source as the processor clock
    *pSCSR |= (0x01UL << 1) ;                                                       // Enables SysTick exception request
    *pSCSR |= (0x01UL << 2) ;                                                       // Indicates the clock source: processor clock source = 1

    //Enable the systick
    *pSCSR |= (0x01UL << 0) ;                                                       // Enables the counter
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack) {
    /* We must change the main stack pointer, but C cannot do that. We must use 
     * inline assembly then.
     * This means we need to use the gcc attribute (naked)
    */
    // __asm__ volatile("MSR MSP, R0") ;
    __asm__ volatile("MSR MSP, %0" : : "r" (sched_top_of_stack) : ) ;           // GCC inline syntax to let us use C variables
    __asm__ volatile("BX LR") ;                                                 // Return from function call
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void init_tasks_stack(void) {
    uint32_t *pPSP ;                                                            // Pointer to Private Stack Pointer

    for (int i = 0 ; i < MAX_TASKS ; i++) {
        pPSP = (uint32_t*)(psp_of_tasks[i]) ;                                   // Set address equal to psp task 1, 2, 3, or 4

        pPSP-- ;
        *pPSP = DUMMY_XPSR ;                                                    // 0x0010_0000

        pPSP-- ;                                                                // PC
        *pPSP = task_handlers[i] ;
        
        pPSP-- ;                                                                // LR
        *pPSP = 0xFFFFFFFD ;

        for (int j = 0 ; j < 13 ; j++) {                                        // Next 13 registers = 0
            pPSP-- ;
            *pPSP = 0 ;
        }

        psp_of_tasks[i] = (uint32_t)pPSP ;                                      // Store the value of PSP after leaving the loop
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void enable_processor_faults(void) {
    // 1. Enable all configurable exceptions like usage fault, mem manage fault, and bus fault
    uint32_t *pSHCSR = (uint32_t*) (0xE000ED24) ;

    *pSHCSR |= (1 << 16) ;                                              // Mem Manage
    *pSHCSR |= (1 << 17) ;                                              // Bus Fault
    *pSHCSR |= (1 << 18) ;                                              // Usage Fault

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint32_t get_psp_value(void) {
    return psp_of_tasks[current_task] ;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__attribute__((naked)) void switch_sp_to_psp(void) {
    // 1. Initialize the PSP with TASK1 stack start
    // Get the value of PSP of current_task
    __asm__ volatile("PUSH {LR}") ;                                     // Presever LR which connects back to main()
    __asm__ volatile("BL get_psp_value") ;
    __asm__ volatile("MSR PSP, R0") ;                                   // Initialize PSP
    __asm__ volatile("POP {LR}") ;                                      // Pops back LR value

    // 2. Change SP to PSP using CONTROL register
    __asm__ volatile("MOV R0, #0x02") ;
    __asm__ volatile("MSR CONTROL, R0") ;
    __asm__ volatile("BX LR") ;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void SysTick_Handler(void) {

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 2. Implement the fault handlers
// Go to startup file and lookup the busfault handler
void HardFault_Handler(void) {
    printf("Exception: HardFault\n") ;
    while (1) ;
}

void MemManage_Handler(void) {
    printf("Exception: MemManage\n") ;
    while (1) ;
}

void BusFault_Handler(void) {
    printf("Exception: BusFault\n") ;
    while (1) ;
}
