/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/*
 *  Exercise:
 *      Write a program to enable all configurable fault exceptions, and implement
 *      the fault exception handlers and cause the fault by the following method
 *          1)  Execute an undefined instruction
 *          2)  Divide by zero
 *          3)  Try executing instruction from peripheral region
 *          4)  Executing SVC inside the SVC handler
 *          5)  Executing SVC instruction inside the interrupt handler whose
 *              priority is same or lesser than SVC handler
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* Function Prototypes */
extern void initialise_monitor_handles(void) ;									// Debugger
void UsageFault_Handler_C(uint32_t *pMSP) ;

int main(void)
{
	initialise_monitor_handles() ;                                          	// Debugger

    // 1. Enable all configurable exceptions like usage fault, mem manage fault, and bus fault
    uint32_t *pSHCSR = (uint32_t*) (0xE000ED24) ;

    *pSHCSR |= (1 << 16) ;                                              // Mem Manage
    *pSHCSR |= (1 << 17) ;                                              // Bus Fault
    // *pSHCSR |= (1 << 18) ;                                              // Usage Fault


    // 3. Let's force the processor to execute some undefined instruction
    uint32_t *pSRAM = (uint32_t*) (0x20010000) ;

    *pSRAM  = 0xFFFFFFFF ;                                              // Choose a random address from SRAM

    void (*some_address) (void) ;                                       // Store invalid instruction into SRAM address above

#if 0
    some_address = (void*) ( ( (uint32_t) (pSRAM) + 1 ) ) ;             // Thumb state; not legal here. Usage fault. Need T-bit as 1
#elif 1
    some_address = (void*) ( ( (uint32_t) (pSRAM) ) ) ;                 // ARM state; legal, but causes a fault related to state
#endif
    
    some_address();

    // 4. Analyze the fault
    /* Loop forever */
	for(;;);
}

// 2. Implement the fault handlers
// Go to startup file and lookup the busfault handler
void HardFault_Handler(void) {
    printf("Exception: HardFault\n") ;
    while (1) ;
}

void MemManage_Handler(void) {
    printf("Exception: MemManage\n") ;
    while (1) ;
}

void BusFault_Handler(void) {
    printf("Exception: BusFault\n") ;
    while (1) ;
}


/* UsageFault_Handler Subroutine */
__attribute__ ((naked)) void UsageFault_Handler(void) {
    // Here, we extracted the value of MSP which happens to be the
    // base address of the stack frame (thread mode) which got saved
    // during the exception entry from thread mode to handler mode
    __asm ("MRS r0, MSP") ;
    __asm ("B UsageFault_Handler_C") ;                                  // Branch to C Function
}

void UsageFault_Handler_C(uint32_t *pBaseStackFrame) {                  // Pass r0 from subroutine
#if 0                                                                   // Prologue / Epilogue created in sp; NOT GOOD
    __asm ("MRS r0, MSP") ;                                             // Store MSP into R0
    register uint32_t msp_value __asm("r0") ;                           // Use register attribute so it is not stored in the stack,
                                                                        // but rather into R0 using __asm attribute
    uint32_t *pMSP = (uint32_t*) (msp_value) ;                          // Save that value into a pointer variable
#endif

    uint32_t *pUFSR = (uint32_t*) (0xE000ED2A) ;

    printf("Exception: UsageFault\n") ;

    printf("UFSR = 0x%lX\n", (*pUFSR) & 0xFFFF) ;
    // Refer to M4 Manual and see that 1 means the processor has attempted to execute and undefined instruction
    // 2 means [1] INVSTATE: Invalid state Usage Fault Fault analyzer says same thing

    printf("pBaseStackFrame = 0x%p\n", pBaseStackFrame) ;
    printf("Value of R0     = 0x%lX\n", pBaseStackFrame[0]) ;
    printf("Value of R1     = 0x%lX\n", pBaseStackFrame[1]) ;
    printf("Value of R2     = 0x%lX\n", pBaseStackFrame[2]) ;
    printf("Value of R3     = 0x%lX\n", pBaseStackFrame[3]) ;
    printf("Value of R12    = 0x%lX\n", pBaseStackFrame[4]) ;
    printf("Value of LR     = 0x%lX\n", pBaseStackFrame[5]) ;
    printf("Value of PC     = 0x%lX\n", pBaseStackFrame[6]) ;
    printf("Value of XPSR   = 0x%lX\n", pBaseStackFrame[7]) ;
    
    while (1) ;
}
