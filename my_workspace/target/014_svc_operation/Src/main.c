/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/*
 * Write a program to add, subtract, multiply, and divide 2 operands using
 * SVC Handler and return the result to the thread mode code and print the
 * result. Thread mode should pass 2 operands via the stack frame.
 * Use the SVC number to determine the operation.
 * 
 *      Service Number      Operation
 *      36                  Addition
 *      37                  Subtraction
 *      38                  Multiplication
 *      39                  Division                
 */

#include <stdio.h>
#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// Function Prototype(s)
extern void initialise_monitor_handles(void) ;									// Debugger
void SVC_Handle_c(uint32_t *pBaseStackFrame);

int32_t add_numbers(int32_t x , int32_t y )
{
    int32_t res;
    __asm volatile("SVC #36");
    __asm volatile ("MOV %0,R0": "=r"(res) ::) ;                // Move R0 to the result
    return res;                                                 // Return the result

}


int32_t sub_numbers(int32_t x , int32_t y )
{
    // TODO
    int32_t res ;
    __asm volatile ("SVC #37") ;
    __asm volatile ("MOV %0, R0" : "=r"(res) : :  ) ;
    return res ;

}

int32_t mul_numbers(int32_t x , int32_t y )
{
    //TODO
    int32_t res ;
    __asm volatile ("SVC #38") ;
    __asm volatile ("MOV %0, R0" : "=r"(res) : :  ) ;
    return res ;
}

int32_t div_numbers(int32_t x , int32_t y )
{
    //TODO
    int32_t res ;
    __asm volatile ("SVC #39") ;
    __asm volatile ("MOV %0, R0" : "=r"(res) : :  ) ;
    return res ;
}


int main(void) {
	initialise_monitor_handles() ;                                          	// Debugger

    int32_t res;                                                                // Result

    res = add_numbers(40, -90);                                                 // ADD ;    40 is stored in R0, -90 in R1
    printf("Add result = %ld\n",res);

    res = sub_numbers(25,150);                                                  // SUB
    printf("Sub result = %ld\n",res);

    res = mul_numbers(374,890);                                                 // MUL
    printf("mul result = %ld\n", res);

    res = div_numbers(67,-3);                                                   // DIV
    printf("div result = %ld\n",res);

    /* Loop forever */
	for(;;);
}



__attribute__( ( naked ) ) void SVC_Handler( void )
{
    __asm ("MRS r0,MSP");                                                       // Special to reg (MSP to R0)
    __asm( "B SVC_Handler_c");                                                  // Call C function
}


void SVC_Handler_c(uint32_t *pBaseOfStackFrame)
{
    int32_t arg0 ;
    int32_t arg1 ;
    int32_t res ;

    printf("in SVC handler\n");

    uint8_t *pReturn_addr = (uint8_t*)pBaseOfStackFrame[6];

    //2. decrement the return address by 2 to point to
    //opcode of the SVC instruction in the program memory
    pReturn_addr-=2;


    //3. extract the SVC number (LSByte of the opcode)
    uint8_t svc_number = *pReturn_addr;

    printf("Svc number is : %d\n",svc_number);

    arg0 = pBaseOfStackFrame[0] ;                                                   // Get the value of R0 from the stack frame
    arg1 = pBaseOfStackFrame[1] ;                                                   // Get the value of R1 from the stack frame


/*SVC number signifies the type of operation , decode it */
    switch(svc_number) {
        case 36:
            /*TODO:addition */
            res = arg0 + arg1 ;                                                     // TODO
            break;
        case 37:
            /*TODO:Subtraction*/
            res = arg0 - arg1 ;
            break;
        case 38:
            /*TODO:Multiplication*/
            res = arg0 * arg1 ;
            break;
        case 39:
            /*TODO:division*/
            res = arg0 / arg1 ;
            break;
        default:
            printf("Invalid svc code\n");
    }

/*store the result back to stack frame at R0's position */
    // pBaseOfStackFrame[0] = <store the result here > //TODO
    pBaseOfStackFrame[0] = res ;
}
