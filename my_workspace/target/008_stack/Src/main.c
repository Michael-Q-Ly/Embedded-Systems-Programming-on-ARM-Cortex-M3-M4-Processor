/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/*
 * Not necessary to use PSP, but if you are doing OS design or if the application
 * is involved with kernel or threadmode code, we will use this technique
 * 
 * 
 * Look at vector table information in the startup file
 * under g_pfnvectors:
 * The first thing we should see is initial stack address _estack.
 * We can also pull up the FLASH.ld file to see whwat _estack is defined
 * as.
 * Next, if we look a few lines down, we see the memory definitions
 * For the STM32F429ZIT, we see
 * Origin_of_SRAM + Total_Size_of_RAM = Initial_Stack_Address
 * (0x2000_0000)   + (192k * 1024)    = 0x2003_0000,
 * where Total_Size_of_RAM is converted from decimal to hex.
 * If we look at MSP, it is the same value as sp, while psp is 0x0
 * because nowhere in the code is psp used.
 * 
 * Function Call and AAPCS Standard:
 * Registers R0 through R3 are used to pass arguments. Any more than
 * 4 and they go to SP.
 * Registers R0 & R1 are used to pass results (return a value).
 * If we look inside stack.list, go to main, we see that R0-R3
 * are used to pass 1, 4, 5, 6 to fun_add, and we branch and link
 * to that function.
 * If we go further down to the fun_add function, we will see that we
 * store the values from R0-R3 into the stack, where R7 is used as sp.
 * Since R7 is a callee saved register, before modifying R7, the callee
 * saves R7 with a push {R7}
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

/* This function executes in the THREAD MODE + PRIV ACCESS LEVEL of the processor */
int main(void) {
	initialise_monitor_handles() ;                                          // Debugger

    change_sp_to_psp() ;

    int sum ;

    sum = fun_add(1, 4, 5, 6) ;

    printf("Result = %d\n", sum) ;

    generate_exception() ;

    /* Loop forever */
	for(;;);
}

int fun_add(int a, int b, int c, int d) {
    int sum = a + b + c + d ;
    return sum ;
}

__attribute__((naked)) void change_sp_to_psp(void) {
    // Use equ assembler directive .equ label, <value> instead of #define macro
    __asm volatile (".equ SRAM_END, (0x20000000 + (192 * 1024) )") ;
    __asm volatile (".equ PSP_START, (SRAM_END - 512)") ;

    __asm volatile ("LDR R0, =PSP_START") ;                                 // Cannot use C macros inside inline assembly
    __asm volatile ("MSR PSP, R0") ;
    __asm volatile ("MOV R0, 0x02") ;
    __asm volatile ("MSR CONTROL, R0") ;

    // Return to main function
    __asm volatile ("BX LR") ;
}

void generate_exception(void) {
    __asm volatile ("SVC #0x02") ;                                          // Change sp value back to MSP's value
}

void SVC_Handler(void) {
    printf("In SVC_Handler") ;
}